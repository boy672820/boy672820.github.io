---
layout: post
title: Rust#3 함수 동작 원리
categories: [rust]
tags: [basic, rust]
description: Rust 입문, 함수 동작 원리에 대해서
---

# 함수 동작 원리

Rust에서 fn은 함수를 정의하는 키워드이고, (대부분 언어에서)`main` 함수는 실행 시점이다.

```rust
fn main() {
	println!("Hello, world!");

	another_fn();
}

fn another_fn() {
	println!("Another function.");
}
```

### Rust 함수 특징

- 암묵적으로 스네이크 표기법(Snake case)를 사용
- 함수 호출부 아래에 호출하려는 함수가 정의되어 있어도 호출 가능 즉, 정의만 되어있으면 됨

### 함수 매개변수(Parameter)

매개변수는 아래와 같이 **타입과 함께 정의**한다. 호출 시 매개변수(Parameters)를 상수 형태로써 전달인자(Arguments)로 제공한다.

매개변수 타입 정의를 통해 명확한 함수 사용과 함수에 의도를 추측하지 않게한다.

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```

## 구문과 표현식

지금까지 표현식 없는 함수만 다뤘기에, 표현식이 구문의 일부로 느낄 수 있다. Rust는 표현식 기반 언어로 구문과 표현식에 차이점을 이해하는 것이 중요히다.(다른 언어는 이와 같은 차이점이 없다.)

구문은 명령들의 나열로 값을 반환하지 않는다. 변수와 함수를 정의할 때가 그 예이다.

```rust
fn main() {
	// 구문을 통한 변수 y에 6 할당
	let y = 6;
	// 구문은 값을 반환하지 않기 때문에 에러가 발생한다.
	let x = (let x = 6);
}
```

위와 같이 x변수에 또다른 x를 정의하는 구문은 값을 반환하지 않기 때문에 에러가 발생한다. 이는 JavaScript, C, Ruby와의 차이점이다.(x = y = 6 형태 가능, 이는 Rust에서 허용하지 않는다.)

반면, `6 + 5` 같은 연산은 11이란 **값을 산출하는 표현식**이다. 표현식은 구문의 부분일 수 있다. 예를 들어, `let y = 6` 이라는 구문은 6이라는 표현식을 갖는다. 6은 6 이란 값을 반환하는 표현식이다.

이처럼 6과 같은 값, 함수 호출, 매크로, 범위 생성 블록 `{}` 들은 표현식이다.

```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

이 코드에서 표현식 부를 살펴보면(변수 y에 할당된 범위)

```rust
{
    let x = 3;
    x + 1
}
```

이 경우 범위 블록 `{}` 은 4를 반환한다. 앞서 봐온 것과 다르게 `x + 1` **세미콜론이 없는데 이는 표현식으로 세미콜론을 사용하지 않는다.** 세미콜론을 표현식 마지막에 추가하면, 이는 구문으로 변경되고 반환 값이 아니게된다.

### 함수 반환

반환 타입은 화살표(→) 뒤에 선언한다.(굳이 명명하지 않아도 됨) 반환은 표현식으로 표현할 수 있다. `return` 키워드를 사용할 수 있지만, Rust에서 대부분 암묵적으로 반환을 표현식으로 사용한다.

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

위 `five()` 함수에서 5라는 표현식으로 반환하였다. 만약 뒤에 세미콜론 붙인다면, 이는 구문으로 반환 값이 없는 함수가 되고 타입 에러가 나올 것이다. 값을 반환하지 않는 함수는 `()` 처럼 비어있는 튜플로 표현된다.